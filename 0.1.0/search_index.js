var documenterSearchIndex = {"docs":
[{"location":"#Quats.jl","page":"Home","title":"Quats.jl","text":"This package provides a bare-bones representation of attitude transformations through quaternions, rotation vectors, and transformation matrices (a.k.a. direction cosine matrices – DCM). ","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"Just type:\n\nusing Pkg\nPkg.add(url=\"https://github.com/FraCpl/Quats.jl\")","category":"section"},{"location":"#Notation-and-conventions","page":"Home","title":"Notation and conventions","text":"Given a 3-dimensional vector v, a reference frame A and a reference frame B, we indicate with  v^A the projection of v into A, and with v^B its projection in B, so that the two  projections can be related through the transformation matrix R_AB as follows\n\nv^A = R_AB v^B\n\nThe same transformation can be represented using the quaternion q_AB\n\nbeginbmatrix 0 v^Aendbmatrix = q_AB  beginbmatrix 0 v^Bendbmatrix  q_AB^*\n\nIn this package, quaternions are represented as 4-dimensional vectors, using the basic vector format natively provided by Julia. The scalar component of the quaternion corresponds to its first element,  i.e., q[1]. We use a right-handed passive convention for representing attitude  transformations through quaternions, and use theta_AB to indicate the angle by which the frame  A needs to be actively rotated to make it coincide with frame B (i.e., the rotation from A to B).\n\nnote: Note\nOther (and weirder) quaternions notations exist in the litterature, which are obviously not covered by this package.","category":"section"},{"location":"#API","page":"Home","title":"API","text":"","category":"section"},{"location":"#Quats","page":"Home","title":"Quats","text":"","category":"section"},{"location":"#Transformation-matrices","page":"Home","title":"Transformation matrices","text":"","category":"section"},{"location":"#Rotation-vectors","page":"Home","title":"Rotation vectors","text":"","category":"section"},{"location":"#Cross-product-functions","page":"Home","title":"Cross product functions","text":"","category":"section"},{"location":"#Index","page":"Home","title":"Index","text":"","category":"section"},{"location":"#Quats.q_build-Tuple{Any, Any}","page":"Home","title":"Quats.q_build","text":"q_build(qs,qv)\n\nBuild a quaternion from its scalar and vectorial components.\n\n\n\n\n\n","category":"method"},{"location":"#Quats.q_derivative!-Tuple{Any, Any, Any}","page":"Home","title":"Quats.q_derivative!","text":"q_derivative!(q̇_AB, q_AB, ωAB_B)\n\nCompute the time derivative of a unitary quaternion, given the corresponding angular velocity vector.\n\nMathematically, this function performs the following operation:\n\nq̇_AB = frac12 q_AB  0 ω^B_AB\n\nwhere ωAB_B represents the angular velocity of frame B with respect to frame A, projected into frame B.\n\n\n\n\n\n","category":"method"},{"location":"#Quats.q_derivative-Tuple{Any, Any}","page":"Home","title":"Quats.q_derivative","text":"q̇_AB = q_derivative(q_AB, ωAB_B)\n\nCompute the time derivative of a unitary quaternion, given the corresponding angular velocity vector.\n\nMathematically, this function performs the following operation:\n\nq̇_AB = frac12 q_AB  0 ω^B_AB\n\nwhere ωAB_B represents the angular velocity of frame B with respect to frame A, projected into frame B.\n\n\n\n\n\n","category":"method"},{"location":"#Quats.q_exp-Tuple{Any}","page":"Home","title":"Quats.q_exp","text":"qe = q_exp(q)\n\nCompute the exponential of the input quaternion.\n\n\n\n\n\n","category":"method"},{"location":"#Quats.q_fromAxisAngle-Tuple{Any, Any}","page":"Home","title":"Quats.q_fromAxisAngle","text":"q_AB = q_fromAxisAngle(u, θ_AB)\n\nCompute the unitary quaternion given as input an axis-angle representation.\n\n\n\n\n\n","category":"method"},{"location":"#Quats.q_fromDcm-Tuple{Any}","page":"Home","title":"Quats.q_fromDcm","text":"q_AB = q_fromDcm(R_AB)\n\nTranslate the input rotation matrix into a unitary quaternion.\n\n\n\n\n\n","category":"method"},{"location":"#Quats.q_identity-Tuple{}","page":"Home","title":"Quats.q_identity","text":"q_identity()\n\nGet identity quaternion, with scalar component equal to 1 and vector components equal to zero.\n\n\n\n\n\n","category":"method"},{"location":"#Quats.q_inverse-Tuple{Any}","page":"Home","title":"Quats.q_inverse","text":"q⁻¹ = q_inverse(q)\n\nCompute the inverse of the input quaternion.\n\n\n\n\n\n","category":"method"},{"location":"#Quats.q_log-Tuple{Any}","page":"Home","title":"Quats.q_log","text":"ql = q_log(q)\n\nCompute the logarithm of the input quaternion.\n\n\n\n\n\n","category":"method"},{"location":"#Quats.q_multiply-Tuple{Any, Any}","page":"Home","title":"Quats.q_multiply","text":"q_AC = q_multiply(q_AB, q_BC)\n\nMutliply the two input quaternions as follows:\n\nq_AC = q_AB  q_BC\n\n\n\n\n\n","category":"method"},{"location":"#Quats.q_multiplyn-Tuple","page":"Home","title":"Quats.q_multiplyn","text":"q = q_multiplyn(q1, q2, q3, ...)\n\n    q = q₁  q₂  q₃  \n\n\n\n\n\n","category":"method"},{"location":"#Quats.q_random-Tuple{}","page":"Home","title":"Quats.q_random","text":"q_random()\n\nGenerate a random unitary quaternion.\n\n\n\n\n\n","category":"method"},{"location":"#Quats.q_rate-Tuple{Any, Any}","page":"Home","title":"Quats.q_rate","text":"This uses rotation vector to compute the average angular rate between two sampled quaternion values, knowing that: q[k] = q[k-1] o dq and angRate(t) = dtheta/dt for t in [t[k-1],t[k]] This means that angRate is the equivalent constant average rate that rotates q[k-1] into q[k].\n\n\n\n\n\n","category":"method"},{"location":"#Quats.q_slerp-Tuple{Any, Any, Any}","page":"Home","title":"Quats.q_slerp","text":"q = q_slerp(q0, q1, τ)\n\nCompute the spherical linear interpolation between two quaternions at τ, where q0 = q[τ=0], q1 = q[τ=1], and q = q[τ].\n\n\n\n\n\n","category":"method"},{"location":"#Quats.q_toDcm-Tuple{Any}","page":"Home","title":"Quats.q_toDcm","text":"R_AB = q_toDcm(q_AB)\n\nTranslate the input unitary quaternion into a transformation matrix.\n\nR_AB(q_AB) = I + 2qₛqᵥ + 2qᵥ²\n\n\n\n\n\n","category":"method"},{"location":"#Quats.q_tox!-Tuple{Any, Any}","page":"Home","title":"Quats.q_tox!","text":"q_tox!(xB_A, q_AB)\n\nCompute the x axis of frame B projected in frame A.\n\n\n\n\n\n","category":"method"},{"location":"#Quats.q_tox-Tuple{Any}","page":"Home","title":"Quats.q_tox","text":"xB_A = q_tox(q_AB)\n\nCompute the x axis of frame B projected in frame A.\n\n\n\n\n\n","category":"method"},{"location":"#Quats.q_toy!-Tuple{Any, Any}","page":"Home","title":"Quats.q_toy!","text":"q_toy!(yB_A, q_AB)\n\nCompute the y axis of frame B projected in frame A.\n\n\n\n\n\n","category":"method"},{"location":"#Quats.q_toy-Tuple{Any}","page":"Home","title":"Quats.q_toy","text":"yB_A = q_toy(q_AB)\n\nCompute the y axis of frame B projected in frame A.\n\n\n\n\n\n","category":"method"},{"location":"#Quats.q_toz!-Tuple{Any, Any}","page":"Home","title":"Quats.q_toz!","text":"q_toz!(zB_A, q_AB)\n\nCompute the z axis of frame B projected in frame A.\n\n\n\n\n\n","category":"method"},{"location":"#Quats.q_toz-Tuple{Any}","page":"Home","title":"Quats.q_toz","text":"zB_A = q_toz(q_AB)\n\nCompute the z axis of frame B projected in frame A.\n\n\n\n\n\n","category":"method"},{"location":"#Quats.q_transformVector!-Tuple{Any, Any, Any}","page":"Home","title":"Quats.q_transformVector!","text":"q_transformVector!(v_A, q_AB, v_B)\n\nProject the vector v from frame B into frame A.\n\n\n\n\n\n","category":"method"},{"location":"#Quats.q_transformVector-Tuple{Any, Any}","page":"Home","title":"Quats.q_transformVector","text":"v_A = q_transformVector(q_AB, v_B)\n\nProject the vector v from frame B into frame A.\n\n\n\n\n\n","category":"method"},{"location":"#Quats.q_transformVectorT!-Tuple{Any, Any, Any}","page":"Home","title":"Quats.q_transformVectorT!","text":"q_transformVectorT!(v_A, q_BA, v_B)\n\nProject the vector v from frame B into frame A, using q_BA.\n\n\n\n\n\n","category":"method"},{"location":"#Quats.q_transpose!-Tuple{Any}","page":"Home","title":"Quats.q_transpose!","text":"q' = q_transpose(q)\n\nTranspose the input quaternion.\n\n\n\n\n\n","category":"method"},{"location":"#Quats.dcm_fromAxes-Tuple{Any, Any, Any}","page":"Home","title":"Quats.dcm_fromAxes","text":"R_AB = dcm_fromAxes(xB_A, yB_A, zB_A)\n\nCompute the transformation matrix given as input the axes of a reference frame.\n\n\n\n\n\n","category":"method"},{"location":"#Quats.dcm_fromAxisAngle-Tuple{Any, Any}","page":"Home","title":"Quats.dcm_fromAxisAngle","text":"R_AB = dcm_fromAxisAngle(u, θ_AB)\n\nCompute the transformation matrix given the axis and angle.\n\nR_AB(θ_AB) = I + sin(θ_AB)u + (1 - cos(θ_AB))u^2\n\n\n\n\n\n","category":"method"},{"location":"#Quats.dcm_fromQuaternion-Tuple{Any}","page":"Home","title":"Quats.dcm_fromQuaternion","text":"R_AB = dcm_fromQuaternion(q_AB)\n\nCompute a transformation matrix from a quaternion.\n\n\n\n\n\n","category":"method"},{"location":"#Quats.dcm_random-Tuple{}","page":"Home","title":"Quats.dcm_random","text":"dcm_random()\n\nGenerate a random transformation matrix.\n\n\n\n\n\n","category":"method"},{"location":"#Quats.dcm_toQuaternion-Tuple{Matrix}","page":"Home","title":"Quats.dcm_toQuaternion","text":"q_AB = dcm_toQuaternion(R_AB)\n\nTranslate a transformation matrix into a quaternion.\n\n\n\n\n\n","category":"method"},{"location":"#Quats.addCross!-Tuple{Any, Any, Any}","page":"Home","title":"Quats.addCross!","text":"addCross!(a, b, c)\n\nCompute a += b × c.\n\n\n\n\n\n","category":"method"},{"location":"#Quats.addCrossSq!-Tuple{Any, Any, Any}","page":"Home","title":"Quats.addCrossSq!","text":"addCrossSq!(a, b, c)\n\nCompute a += b × (b × c).\n\n\n\n\n\n","category":"method"},{"location":"#Quats.cross!-Tuple{Any, Any, Any}","page":"Home","title":"Quats.cross!","text":"cross!(a, b, c)\n\nCompute a = b × c.\n\n\n\n\n\n","category":"method"},{"location":"#Quats.crossMat-Tuple{Any, Any, Any}","page":"Home","title":"Quats.crossMat","text":"[v×] = crossMat(x, y, z)\n\nCompute the cross product matrix of a vector v given its scalar components.\n\n\n\n\n\n","category":"method"},{"location":"#Quats.crossMat-Tuple{Any}","page":"Home","title":"Quats.crossMat","text":"[v×] = crossMat(v)\n\nCompute the cross product matrix of a vector v.\n\n\n\n\n\n","category":"method"},{"location":"#Quats.crossMatSq-Tuple{Any, Any, Any}","page":"Home","title":"Quats.crossMatSq","text":"[v×]² = crossMatSq(x, y, z)\n\nCompute the squared cross product matrix of a vector v given its scalar components.\n\n\n\n\n\n","category":"method"},{"location":"#Quats.crossMatSq-Tuple{Any}","page":"Home","title":"Quats.crossMatSq","text":"[v×]² = crossMatSq(v)\n\nCompute the squared cross product matrix of a vector v.\n\n\n\n\n\n","category":"method"},{"location":"#Quats.crossSq!-Tuple{Any, Any, Any}","page":"Home","title":"Quats.crossSq!","text":"crossSq!(a, b, c)\n\nCompute a = b × (b × c).\n\n\n\n\n\n","category":"method"}]
}
